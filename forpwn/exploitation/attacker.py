import requests
import asyncio
import random
import re
import time

from collections import defaultdict
from logger import logger
from llm import *
from concurrent.futures import ThreadPoolExecutor

from .sql_injection import expolit as sql_inject
from .file_inclusion import expolit as file_inclusion
from .command_string import expolit as command_string
from .stack_overflow import expolit as stack_overflow
from .format_string import expolit as format_string

def crawler_vul_code(url):
    response = requests.get(url)
    if response.status_code == 200:
        return response.text
    else:
        logger.error(f"Failed to get code from {url}. Code: {response.status_code}. Text: {response.text}. ")
        return None

SOLVERS = [GPT4OSolver, ]

executor = ThreadPoolExecutor(max_workers=10)

async def wait_async_tasks(tasks, timeout):
    tasks = [asyncio.create_task(task) for task in tasks]
    return await asyncio.wait(tasks, timeout=timeout)

def run_async_tasks(tasks, timeout):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    results = loop.run_until_complete(wait_async_tasks(tasks, timeout))
    return results

SUPPORTED_VULN_TYPES = ["SQL注入", "命令注入", "栈溢出", "格式化字符串", "文件包含"]

class Attacker:
    def __init__(self, file_url: str):
        self.file_url = file_url
        self.code = None
        self.solvers = [s() for s in SOLVERS]
        self.vuln_type = None
        self.line_num = None

    def crawler_vul_code(self) -> bool:
        self.code = crawler_vul_code(self.file_url)
        if self.code is None:
            self.code = crawler_vul_code(self.file_url)
        return self.code is not None

    def sanitize_vuln_type(self, ty):
        ty = ty.replace(" ", "")
        return ty if ty in SUPPORTED_VULN_TYPES else None

    def sanitize_vuln_line(self, num):
        if not isinstance(num, int):
            try:
                num = int(num)
            except Exception as e:
                logger.error(e)
                return None
        if num <= 0 or num > len(self.code.splitlines()):
            return None
        return num

    def get_vuln_type(self, time_limit):
        if self.vuln_type:
            return self.vuln_type
        self.determine_vuln_type_and_line(time_limit)
        if self.vuln_type is None:
            self.vuln_type = random.choice(SUPPORTED_VULN_TYPES)
        return self.vuln_type

    def get_vuln_line(self, time_limit):
        if self.line_num:
            return self.line_num
        self.determine_vuln_type_and_line(time_limit)
        if self.line_num is None:
            self.line_num = random.choice(list(range(len(self.code.splitlines())))) + 1
        return self.line_num

    def determine_vuln_type_and_line(self, time_limit) -> tuple[str, int]:
        if self.code is None:
            return None, None
        tasks = [s.ask_for_vuln_type_and_line(self.code, time_limit) for s in self.solvers]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        results = [(vuln_type, b) for vuln_type, b in results if vuln_type is not None]
        if len(results) == 0:
            return None, None
        voted = defaultdict(lambda: [0, defaultdict(lambda: 0)])
        for vuln_type, line_num in results:
            vuln_type = self.sanitize_vuln_type(vuln_type)
            line_num = self.sanitize_vuln_line(line_num)
            if vuln_type is None:
                continue
            voted[vuln_type][0] += 1
            if line_num:
                voted[vuln_type][1][line_num] += 1
        x = max(list(voted.items()), key=lambda x: x[1][0])
        self.vuln_type = x[0]
        self.line_num = max(list(x[1][1].items()), key=lambda x: x[1])[0]
        return self.vuln_type, self.line_num
    
    def sanitize_flag(self, flag):
        if flag is None:
            return None
        flag_pattern = r"flag\{[^}]*\}"
        flag_match = re.search(flag_pattern, flag)
        if flag_match:
            return flag_match.group(0)
        return None
    
    async def expolit_once(self, url: str, s: LLMSolver, time_limit: float):
        start = time.time()
        expolitation_functions = {
            "SQL注入": sql_inject, 
            "文件包含": file_inclusion,
            "栈溢出": stack_overflow, 
            "格式化字符串": format_string,
            "命令注入": command_string, 
        }
        expolit_func = expolitation_functions[self.vuln_type]
        flag = None
        remaining = time_limit - (time.time() - start)
        while flag is None and (remaining > 2):
            # 1s for conducting expolitation. 
            typed_payload = await s.ask_for_payload(url, self.vuln_type, remaining - 1.0)
            logger.info(f"Get payload: {typed_payload}")
            flag = expolit_func(url, *typed_payload)
            flag = self.sanitize_flag(flag)
            remaining = time_limit - (time.time() - start)
            time.sleep(1)   # test time only, to avoid costing too much
            s.revert()
        return flag

    def expolit(self, url: str, time_limit) -> str:
        if self.vuln_type in ["SQL注入", "文件包含", ]:
            # what if command injection in php?
            url = "http://" + url + "/"
        tasks = [self.expolit_once(url, s, time_limit) for s in self.solvers]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        results = [s for s in results if s is not None]
        flag = results[0] if len(results) > 0 else ""
        logger.info(f"Found flag: {flag}")
        return flag
