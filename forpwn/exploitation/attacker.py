import requests
import asyncio
import random
import re
import time
import threading

from collections import defaultdict
from logger import logger
from llm import *
from concurrent.futures import ThreadPoolExecutor

from .sql_injection import expolit as sql_inject
from .file_inclusion import expolit as file_inclusion
from .command_string import expolit as command_string
from .stack_overflow import expolit as stack_overflow
from .format_string import expolit as format_string

def crawler_vul_code(url):
    response = requests.get(url)
    if response.status_code == 200:
        return response.text
    else:
        logger.error(f"Failed to get code from {url}. Code: {response.status_code}. Text: {response.text}. ")
        return None

SOLVERS = [GPT4OSolver, GPT4OSolver, GPT4OSolver, ]

executor = ThreadPoolExecutor(max_workers=10)

async def wait_async_tasks(tasks, timeout):
    tasks = [asyncio.create_task(task) for task in tasks]
    return await asyncio.wait(tasks, timeout=timeout)

def run_async_tasks(tasks, timeout):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    results = loop.run_until_complete(wait_async_tasks(tasks, timeout))
    return results

SUPPORTED_VULN_TYPES = ["SQL注入", "命令注入", "栈溢出", "格式化字符串", "文件包含"]

IP_PLACEHOLDER = "IP_PLACEHOLDER"
PORT_PLACEHOLDER = "PORT_PLACEHOLDER"
URL = f"{IP_PLACEHOLDER}:{PORT_PLACEHOLDER}"
HTTP_URL = f"http://{URL}/"
WEB_Vuln = ["文件包含"]
def substitute_ip_port(typed_payload, url):
    if url.startswith("http://"):
        ip, port = url[7:].split(":")
    else:
        ip, port = url.split(":")
    payload_type, text, text2 = typed_payload
    text = text.replace(IP_PLACEHOLDER, ip)
    text = text.replace(PORT_PLACEHOLDER, port)
    return payload_type, text, text2

class Attacker:
    def __init__(self, file_url: str):
        self.file_url = file_url
        self.code = None
        self.solvers = [s() for s in SOLVERS]
        self.vuln_type = None
        self.line_num = None
        self.payloads = []

        self.vuln_type_found = threading.Event()
        self.line_num_found = threading.Event()
        self.payload_found = threading.Event()

    def crawler_vul_code(self) -> bool:
        self.code = crawler_vul_code(self.file_url)
        if self.code is None:
            self.code = crawler_vul_code(self.file_url)
        return self.code is not None

    def sanitize_vuln_type(self, ty):
        ty = ty.replace(" ", "")
        return ty if ty in SUPPORTED_VULN_TYPES else None

    def sanitize_vuln_line(self, num):
        if not isinstance(num, int):
            try:
                num = int(num)
            except Exception as e:
                logger.error(e)
                return None
        if num <= 0 or num > len(self.code.splitlines()):
            return None
        return num

    def set_vuln_type_found(self):
        if self.vuln_type is None:
            self.vuln_type = random.choice(SUPPORTED_VULN_TYPES)
        self.vuln_type_found.set()

    def set_line_num_found(self):
        if self.line_num is None:
            self.line_num = random.choice(list(range(len(self.code.splitlines())))) + 1
        self.line_num_found.set()

    def set_payload_found(self):
        self.payload_found.set()

    def get_vuln_type(self):
        self.vuln_type_found.wait()
        return self.vuln_type

    def get_vuln_line(self):
        self.line_num_found.wait()
        return self.line_num
    
    def get_payload(self):
        self.payload_found.wait()
        return self.payloads


    def determine_vuln_type_and_line(self, time_limit) -> tuple[str, int]:
        if self.code is None:
            return None, None
        tasks = [s.ask_for_vuln_type_and_line(self.code, time_limit) for s in self.solvers]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        results = [(vuln_type, b) for vuln_type, b in results if vuln_type is not None]
        if len(results) == 0:
            return None, None
        voted = defaultdict(lambda: [0, defaultdict(lambda: 0)])
        for vuln_type, line_num in results:
            vuln_type = self.sanitize_vuln_type(vuln_type)
            line_num = self.sanitize_vuln_line(line_num)
            if vuln_type is None:
                continue
            voted[vuln_type][0] += 1
            if line_num:
                voted[vuln_type][1][line_num] += 1
        x = max(list(voted.items()), key=lambda x: x[1][0])
        self.vuln_type = x[0]
        self.line_num = max(list(x[1][1].items()), key=lambda x: x[1])[0]
        return self.vuln_type, self.line_num
    
    def sanitize_flag(self, flag):
        # if flag is bytes:
        if isinstance(flag, bytes):
            flag_pattern = rb"flag\{[^}]*\}"
            flag_match = re.search(flag_pattern, flag)
            if flag_match:
                return flag_match.group(0).decode()
            return None
        if flag is None:
            return None
        flag_pattern = r"flag\{[^}]*\}"
        flag_match = re.search(flag_pattern, flag)
        if flag_match:
            return flag_match.group(0)
        return None
    
    def ask_for_payload(self, time_limit: float):
        start = time.time()
        typed_payload = None
        url = HTTP_URL if self.vuln_type in WEB_Vuln else URL
        remaining = time_limit - (time.time() - start)
        if self.vuln_type == "格式化字符串":
            from copy import deepcopy
            self.solvers = self.solvers + [deepcopy(s) for s in self.solvers]
        tasks = [s.ask_for_payload(url, self.vuln_type, remaining - 1.0, None) for s in self.solvers]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        self.payloads = results
    
    async def expolit_once(self, url: str, s: LLMSolver, time_limit: float):
        start = time.time()
        expolitation_functions = {
            "SQL注入": sql_inject, 
            "文件包含": file_inclusion,
            "栈溢出": stack_overflow, 
            "格式化字符串": format_string,
            "命令注入": command_string, 
        }
        expolit_func = expolitation_functions[self.vuln_type]
        flag, nxt_prompt = None, None
        remaining = time_limit - (time.time() - start)
        while flag is None and (remaining > 2):
            # 1s for conducting expolitation. 
            if self.payloads:
                logger.info(f"payloads length: {len(self.payloads)}")
                typed_payload = self.payloads[0]
                self.payloads = self.payloads[1:]
            else:
                typed_payload = await s.ask_for_payload(url, self.vuln_type, remaining - 1.0, nxt_prompt)
            typed_payload = substitute_ip_port(typed_payload, url)
            logger.info(f"typed_payload: {typed_payload}")
            flag, nxt_prompt = await expolit_func(url, *typed_payload)
            flag = self.sanitize_flag(flag)
            remaining = time_limit - (time.time() - start)
            time.sleep(1)   # [IMP] test time only, to avoid costing too much
            if nxt_prompt is None:
                # No further prompt, revert to re-generate payload. 
                s.revert()
        return flag
    
    async def execute_once(self, url: str, typed_payload, time_limit: float):
        expolitation_functions = {
            "SQL注入": sql_inject, 
            "文件包含": file_inclusion,
            "栈溢出": stack_overflow, 
            "格式化字符串": format_string,
            "命令注入": command_string, 
        }
        expolit_func = expolitation_functions[self.vuln_type]
        flag, nxt_prompt = None, None
        typed_payload = substitute_ip_port(typed_payload, url)
        logger.info(f"typed_payload: {typed_payload}")
        flag, nxt_prompt = await expolit_func(url, *typed_payload)
        flag = self.sanitize_flag(flag)
        return flag

    def expolit(self, url: str, time_limit) -> str:
        if self.vuln_type in WEB_Vuln:
            # what if command injection in php?
            url = "http://" + url + "/"

        if self.payloads:
            logger.info(f"Found number of payloads: {len(self.payloads)}")
            tasks = [self.execute_once(url, typed_payload, time_limit) for typed_payload in self.payloads]
            done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
            results = [task.result() for task in done]
            results = [s for s in results if s is not None]
            flag = results[0] if len(results) > 0 else ""
            logger.info(f"Found flag: {flag}")
            return flag
        tasks = [self.expolit_once(url, s, time_limit) for s in self.solvers]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        results = [s for s in results if s is not None]
        flag = results[0] if len(results) > 0 else ""
        logger.info(f"Found flag: {flag}")
        return flag
