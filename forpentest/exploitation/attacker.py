import requests
import asyncio
import random
import re
import os
import time
import shutil
import threading

from collections import defaultdict
from logger import logger
from llm import *
from concurrent.futures import ThreadPoolExecutor
from subprocess import Popen, PIPE
from os.path import join

def download_zip(url, fp):
    os.makedirs(os.path.dirname(fp), exist_ok=True)
    response = requests.get(url)
    if response.status_code == 200:
        with open(fp, "wb") as f:
            f.write(response.content)
        return fp
    else:
        logger.error(f"Failed to get file from {url}. Code: {response.status_code}. Text: {response.text}. ")
        return None

SOLVERS = [GPT4OSolver, ]

executor = ThreadPoolExecutor(max_workers=2)

async def wait_async_tasks(tasks, timeout):
    tasks = [asyncio.create_task(task) for task in tasks]
    return await asyncio.wait(tasks, timeout=timeout)

def run_async_tasks(tasks, timeout):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    results = loop.run_until_complete(wait_async_tasks(tasks, timeout))
    return results

def popen_wrapper(args, cwd="tmp"):
    logger.info(f"Popen {args}")
    p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=cwd)
    return p.communicate()

class Attacker:
    def __init__(self, file_url: str):
        self.file_url = file_url
        self.zipfp = None
        self.tmpdir = "tmp"
        self.extracteddir = "tmp/extracted"
        self.files = []

        self.task_completed = threading.Event()

        self.solvers = [s() for s in SOLVERS]
        self.vuln_type = None
        self.line_num = None

    def download_zip(self) -> bool:
        fp = join(self.tmpdir, "demo.zip")
        self.zipfp = download_zip(self.file_url, fp)
        if self.zipfp is None:
            self.zipfp = download_zip(self.file_url, fp)
        return self.zipfp is not None
    
    def extract_zip(self) -> bool:
        shutil.rmtree(self.extracteddir)
        os.makedirs(self.extracteddir)
        zipfp = os.path.relpath(self.zipfp, self.extracteddir)
        o, e = popen_wrapper(["unzip", zipfp], self.extracteddir)
        if e:
            logger.error(f"Encountering errors while extracting zip: {e}")
            o, e = popen_wrapper(["unzip", zipfp], self.extracteddir)
        for root, dirs, files in os.walk(self.extracteddir):
            for fn in files:
                fp = join(root, fn)
                self.files.append(fp)
        logger.info(f"Found files: {self.files}")
        return True
    
    def search_sensitive_info(self):
        self.task_completed.set()

    def get_answers_json(self):
        self.task_completed.wait()
        return {}

