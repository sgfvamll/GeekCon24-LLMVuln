import requests
import asyncio
import random
import re
import os
import time
import shutil
import threading

from collections import defaultdict
from logger import logger
from concurrent.futures import ThreadPoolExecutor
from subprocess import Popen, PIPE
from os.path import join
from difflib import SequenceMatcher

from llm import *
from aync_helper import *

## Utils

def download_zip(url, fp):
    os.makedirs(os.path.dirname(fp), exist_ok=True)
    response = requests.get(url)
    if response.status_code == 200:
        with open(fp, "wb") as f:
            f.write(response.content)
        return fp
    else:
        logger.error(f"Failed to get file from {url}. Code: {response.status_code}. Text: {response.text}. ")
        return None

def popen_wrapper(args, cwd="tmp"):
    logger.info(f"Popen {args}")
    p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=cwd)
    return p.communicate()

def readfile(fp):
    with open(fp, "r") as f:
        return f.read()

## Configures and helper functions

SUPPORTED_SENSITIVE_INFO_TYPE = ["明密文口令", "私钥信息", "云端aksk", "token信息", "内网IP", "对外暴露端口"]

SOLVERS = [GPT4OSolver, ]

def extract_priv_key(segment: str, content: str):
    m = SequenceMatcher(None, content, segment).find_longest_match()
    if m.size == 0:
        return None
    b = content[m.a : m.a + m.size]
    b = max(b.splitlines(), key=lambda x: len(x))
    if len(b) < 5:
        return None

    lines = content.splitlines()
    ptr, s, e = None, None, None
    for i, line in enumerate(lines):
        if b in line:
            ptr = i
        if '-----' in line:
            if ptr is None:
                s = i
            else:
                e = i
                break
    if s is None or e is None:
        return None
    
    priv_key_lines = lines[s:e+1]
    priv_key_lines = [line.lstrip("# ") for line in priv_key_lines]
    return '\n'.join(priv_key_lines) + '\n'


def sanitize_answer(answers: list[dict[str, str]], filename: str, content: str):
    for i, answer in enumerate(answers):
        keys = list(answer.keys())
        for k in keys:
            if not k in SUPPORTED_SENSITIVE_INFO_TYPE:
                del answer[k]
        if len(answer) != 1:
            answer = None
        if answer is not None and "对外暴露端口" in answer:
            try:
                answer["对外暴露端口"] = int(answer["对外暴露端口"])
            except Exception as e:
                answer = None
        if answer is not None and "私钥信息" in answer:
            priv_key = extract_priv_key(answer["私钥信息"], content)
            if priv_key is not None:
                answer["私钥信息"] = priv_key
            else:
                answer["私钥信息"] = None
        # TODO 模型输出的 token信息 有时不完整，需要匹配成完整的
        answers[i] = answer
    answers = [a for a in answers if a is not None]
    if len(answers) == 0:
        return None
    return answers


class Attacker:
    def __init__(self, file_url: str):
        self.file_url = file_url
        self.zipfp = None
        self.tmpdir = "tmp"
        self.extracteddir = "tmp/extracted"
        self.files = []

        self.task_completed = threading.Event()

        self.solvers = [s() for s in SOLVERS]
        self.answers = None

    def download_zip(self) -> bool:
        fp = join(self.tmpdir, "demo.zip")
        self.zipfp = download_zip(self.file_url, fp)
        if self.zipfp is None:
            self.zipfp = download_zip(self.file_url, fp)
        return self.zipfp is not None
    
    def extract_zip(self) -> bool:
        shutil.rmtree(self.extracteddir)
        os.makedirs(self.extracteddir)
        zipfp = os.path.relpath(self.zipfp, self.extracteddir)
        o, e = popen_wrapper(["unzip", zipfp], self.extracteddir)
        if e:
            logger.error(f"Encountering errors while extracting zip: {e}")
            o, e = popen_wrapper(["unzip", zipfp], self.extracteddir)
        for root, dirs, files in os.walk(self.extracteddir):
            for fn in files:
                fp = join(root, fn)
                self.files.append(fp)
        logger.info(f"Found files: {self.files}")
        return True

    def merge_answers(self, answers):
        # TODO
        return answers[0]

    def search_sensitive_info(self, time_limit):
        file_contents = []
        file_to_contents = {}
        for file in self.files:
            fn = os.path.basename(file)
            c = readfile(file)
            file_contents.append((fn, c))
            file_to_contents[fn] = c
        tasks = [s.audit_sensitive_info(fn, c, time_limit - 1) for s in self.solvers for fn, c in file_contents]
        done, pending = executor.submit(run_async_tasks, tasks, time_limit).result()
        results = [task.result() for task in done]
        merged_by_fn = defaultdict(list)
        for fn, infos in results:
            infos = sanitize_answer(infos, fn, file_to_contents[fn])
            if infos is not None:
                merged_by_fn[fn].append(infos)
        answers = {}
        for fn, infos_arr in merged_by_fn.items():
            answers[fn] = self.merge_answers(infos_arr)
        self.answers = answers
        self.task_completed.set()

    def get_answers_json(self):
        self.task_completed.wait()
        return self.answers

