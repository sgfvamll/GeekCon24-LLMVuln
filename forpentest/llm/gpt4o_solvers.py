import os
import json
import time

from openai import OpenAI 
from logger import logger
from config import base_url, api_key
from aiohttp import ClientSession
from urllib.parse import urljoin

from .base import LLMSolver, extract_from_json

## Set the API key and model name
MODEL="chatgpt-4o-latest"

# TODO 需要更多测试，比如 BEGIN RSA PRIVATE KEY 替换成 BEGIN RSA PUBLIC KEY 怎么样
# TODO 大文件或许需要额外处理

system_prompt = '''\
你将作为一名专业的运维，负责审核开发上传的配置文件中是否存在敏感信息。一旦你遗漏了任何可能的敏感信息，可能会给生产环境带来一定的安全隐患。但如果你误报了一些非敏感信息，会带来更多的麻烦。你的职责是：
1. 找到给定配置文件中所有的 明密文口令、私钥信息、云端 aksk、token 信息、内网 IP、对外暴露端口 这六种类型的敏感信息。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"敏感信息类型":"敏感信息内容"}]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。六类敏感信息内容的输出格式列举如下：
- 明密文口令: {"明密文口令":"user:用户名,password:密码"}
- 私钥信息: {"私钥信息":"私钥内容"}。 私钥内容通常很长，只需要输出其中连续的一段（大于8个字符）即可，同一个私钥只需要输出一段。
- 云端 aksk: {"云端aksk":"ak:ak 内容,sk:sk 内容"}
- token 信息: {"token信息":"token 内容"}
- 内网 IP: {"内网IP":"IP 地址"}
- 对外暴露端口: {"对外暴露端口":"端口号"}
这里有一些关于各种配置文件敏感信息的备忘笔记：
1. 明文口令
常见字段名：password、passwd、pass、pwd、secret。
检测要点：
- 任意出现在配置文件中的明文口令都应被视为敏感信息，尤其是以常见字段名表示的字段。
- 可能以 Base64、URL 编码等形式进行简单编码，但仍然属于明文存储。
2. 私钥信息
检测要点：
- 私钥通常是 PEM 格式，具有如下特征：
- 以 -----BEGIN PRIVATE KEY----- 或 -----BEGIN RSA PRIVATE KEY----- 等标志开始。以 -----END PRIVATE KEY----- 或类似标志结束。
- 私钥通常会以多个连续的 Base64 编码行表示，通常长度较长。
3. 云端 AK/SK 信息
常见字段名：access_key、secret_key、api_key、AK、SK、accessKeyId、secretAccessKey 等。
检测要点：
- 云服务商（如 AWS、阿里云、腾讯云等）提供的 AK（Access Key）和 SK（Secret Key）往往由一定长度的字母和数字组成，并且具有特定的长度和格式。
- 这些信息通常出现在与云服务集成的配置中（例如，用于认证或调用 API 的配置字段）。
4. Token 信息
常见字段名：token、auth_token、id_token、jwt、oauth_token、access_token、refresh_token 等。
检测要点：
- Token 通常是较长的字符串，可能包含字母、数字、点号（.）或其他特殊字符。
- 常见 Token 类型包括：
    - JWT (JSON Web Token)：通常由三部分组成，中间以点号（.）分隔。格式类似于 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...。
    - OAuth Token：用于 OAuth2 认证的 Token，通常以长字符串形式出现。
5. 内网 IP
检测要点：
- 127.0.0.1 为本地回环地址，不是内网IP。
常见的 内网IP 段：
- 10.0.0.0 - 10.255.255.255 （10.x.x.x）
- 172.16.0.0 - 172.31.255.255 （172.16.x.x - 172.31.x.x）
- 192.168.0.0 - 192.168.255.255 （192.168.x.x）
检测要点：
- 内网 IP 通常出现在内网服务的配置中，或者是服务之间的通信地址。需要特别注意是否有将内网 IP 误暴露到外部配置文件中。
6. 对外暴露端口
常见字段名：port、hostPort、externalPort、expose 等。
检测要点：
- Kubernetes 或容器配置中的 containerPort 不算对外暴露端口，但 hostPort 是对外暴露的端口。
- 服务端配置文件中直接配置的 port 字段（如 HTTP 服务器、数据库服务、redis服务等，但不包括容器服务）通常可以视为对外暴露的端口，即使仅绑定 127.0.0.1 等本地地址。
'''
# 2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：```[{"敏感信息类型":"敏感信息内容"}]```，请使用用三引号(```)来包裹输出的 JSON Array ，除此之外，不要使用三引号包裹其它任何东西。六类敏感信息内容的输出格式列举如下：

prompt_template = '''这是一个名为 {filename} 的配置文件的内容。{extra_info}请按格式要求输出其中包含的敏感信息：\n{content}'''

emphasize_container_conf = "如果这是一个容器配置文件，则其中 port: xxxx 中的 xxxx 不是对外暴露端口， xxxx:yyyy 格式中的 xxxx 才是。"
extra_info_by_file_type = {
    "yml": emphasize_container_conf, 
    "yaml": emphasize_container_conf, 
}

class GPT4OSolver(LLMSolver):
    def __init__(self):
        super().__init__(system_prompt)
        # self.client = OpenAI(api_key=api_key, base_url=base_url)

    @staticmethod
    async def _ask_gpt(history):
        url = base_url + "/chat/completions"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}', 
        }
        data = {
            "model": MODEL,
            "messages": history,
            "stream": False
        }
        async with ClientSession() as session:
            async with session.post(url, json=data, headers=headers) as response:
                res = await response.json()
                return res['choices'][0]["message"]["content"]

    async def ask_gpt(self, prompt, timeout = 8.0):
        logger.info(f"{prompt = }\n{timeout = }")
        logger.debug(f"{[one['role'] for one in self.history] = }")
        reply = await self._ask_gpt(self.history + [{"role": "user", "content": prompt}])
        logger.info(f"{reply = }")
        try:
            replyjson = json.loads(reply)
        except json.JSONDecodeError as e:
            logger.error(e)
            return None
        
        return replyjson

    async def audit_sensitive_info(self, filename, content, time_limit):
        start = time.time()
        ext = os.path.splitext(filename)[1].lstrip('.')
        extra_info = extra_info_by_file_type.get(ext, '')
        prompt = prompt_template.format(filename=filename, content=content, extra_info=extra_info)

        answer = await self.ask_gpt(prompt, timeout=time_limit)
        remaining = time_limit - (time.time() - start)
        while (answer is None) and (remaining > 2):
            self.revert()
            answer = await self.ask_gpt(prompt, timeout=remaining)
            remaining = time_limit - (time.time() - start)
        return (filename, answer)

if __name__ == '__main__':
    from aync_helper import *
    import logging
    logger.setLevel(logging.INFO)
    samples = {}
    for root, dirs, files in os.walk("tmp/extracted"):
        for fn in files:
            fp = os.path.join(root, fn)
            with open(fp, "r") as f:
                content = f.read()
            samples[fn] = content

    s = GPT4OSolver()
    tasks = [s.audit_sensitive_info(fn, c, 10) for fn, c in samples.items()]
    done, pending = executor.submit(run_async_tasks, tasks, 10).result()
    results = [task.result() for task in done]
    for result in results:
        logger.info("=" * 50)
        logger.info(result)


### Useless
per_type_prompts = [
'''
你的职责是：
1. 找到给定配置文件中所有的 明密文口令 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"明密文口令":"user:用户名,password:密码"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。
检测要点：
常见字段名：password、passwd、pass、pwd、secret等。
- 任意出现在配置文件中的明文口令都应被视为敏感信息，尤其是以常见字段名表示的字段。
- 可能以 Base64、URL 编码等形式进行简单编码，但仍然属于明文存储。
''',
'''
你的职责是：
1. 找到给定配置文件中所有的 私钥信息 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"私钥信息":"私钥内容"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。私钥内容通常很长，只需要输出其中连续的一段（大于8个字符）即可，同一个私钥只需要输出一段。
检测要点：
- 私钥通常是 PEM 格式，具有如下特征：
- 以 -----BEGIN PRIVATE KEY----- 或 -----BEGIN RSA PRIVATE KEY----- 等标志开始。以 -----END PRIVATE KEY----- 或类似标志结束。
- 私钥通常会以多个连续的 Base64 编码行表示，通常长度较长。
''',
'''
你的职责是：
1. 找到给定配置文件中所有的 云端aksk 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"云端aksk":"ak:ak 内容,sk:sk 内容"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。
检测要点：
常见字段名：access_key、secret_key、api_key、AK、SK、accessKeyId、secretAccessKey 等。
- 云服务商（如 AWS、阿里云、腾讯云等）提供的 AK（Access Key）和 SK（Secret Key）往往由一定长度的字母和数字组成，并且具有特定的长度和格式。
- 这些信息通常出现在与云服务集成的配置中（例如，用于认证或调用 API 的配置字段）。
''',
'''
你的职责是：
1. 找到给定配置文件中所有的 Token信息 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"token信息":"token 内容"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。
检测要点：
常见字段名：token、auth_token、id_token、jwt、oauth_token、access_token、refresh_token 等。
- Token 通常是较长的字符串，可能包含字母、数字、点号（.）或其他特殊字符。
- 常见 Token 类型包括：
    - JWT (JSON Web Token)：通常由三部分组成，中间以点号（.）分隔。格式类似于 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...。
    - OAuth Token：用于 OAuth2 认证的 Token，通常以长字符串形式出现。
''',
'''
你的职责是：
1. 找到给定配置文件中所有的 内网IP 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"内网IP":"IP 地址"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。
常见的内网 IP 段：
- 10.0.0.0 - 10.255.255.255 （10.x.x.x）
- 172.16.0.0 - 172.31.255.255 （172.16.x.x - 172.31.x.x）
- 192.168.0.0 - 192.168.255.255 （192.168.x.x）
检测要点：
- 内网 IP 通常出现在内网服务的配置中，或者是服务之间的通信地址。需要特别注意是否有将内网 IP 误暴露到外部配置文件中。
''',
'''
你的职责是：
1. 找到给定配置文件中所有的 对外暴露端口 。
2. **最终输出格式要求**：如果发现敏感信息，使用 JSON Array 格式输出这些信息，模板：`[{"对外暴露端口":"端口号"},]`，你只需要回复一个 JSON Array 数据即可，不需要用三引号来包裹代码块。
检测要点：
- 常见字段名：port、hostPort、externalPort、expose 等。
- Kubernetes 或容器配置中的 containerPort 不算对外暴露端口，但 hostPort 是对外暴露的端口。
- 仅 exposed 但没有映射的端口不算对外暴露端口。在我们的环境里，yaml 或 yml 后缀的配置文件用于容器配置，其中 `port: xxxx` 中的 xxxx 不是对外暴露端口。
- 容器配置文件中，映射到宿主机的端口（即 xxxx:yyyy 中的 xxxx）是对外暴露的端口，而 yyyy 则不是。
- 服务端配置文件中直接配置的 port 字段（如 HTTP 服务器、数据库服务、redis服务等，但不包括容器服务）通常可以视为对外暴露的端口。
''',
]
